# Методы словарей
# Словари как и списки имеют много полезных методов для упрощения работы с ними и решения повседневных задач. В прошлом
# уроке, мы уже познакомились с тремя словарными методами:
#     * метод items() – возвращает словарные пары ключ: значение, как соответствующие им кортежи;
#     * метод keys() – возвращает список ключей словаря;
#     * метод values() – возвращает список значений словаря.


# Добавление и изменение элементов в словаре
# Чтобы изменить значение по определенному ключу в словаре, достаточно использовать индексацию вместе с оператором
# присваивания. При этом если ключ уже присутствует в словаре, его значение заменяется новым, если же ключ отсутствует,
# то в словарь будет добавлен новый элемент.
info = {'name': 'Sam',
        'age': 28,
        'job': 'Teacher'}

info['name'] = 'Timur'                    # изменяем значение по ключу name
info['email'] = 'timyr-guev@yandex.ru'    # добавляем в словарь элемент с ключом email
print(info)  # {'name': 'Timur', 'age': 28, 'job': 'Teacher', 'email': 'timyr-guev@yandex.ru'}


# Обратите внимание на отличие в поведении словарей и списков:
#     * Если в списке lst нет элемента с индексом 77, то попытка обращения к нему, например, с помощью строки кода
#       print(lst[7]) приведет к возникновению ошибки. И попытка присвоить ему значение lst[7] = 100 тоже приведет к
#       возникновению ошибки.
#     * Если в словаре dct нет элемента с ключом name, то попытка обращения к нему, например, с помощью строки кода
#       print(dct['name']) приведет к возникновению ошибки. Однако попытка присвоить значение по отсутствующему ключу
#       dct['name'] = 'Timur' ошибки не вызовет.

# Решим следующую задачу: пусть задан список чисел numbers, где некоторые числа встречаются неоднократно. Нужно узнать,
# сколько именно раз встречается каждое из чисел.
numbers = [9, 8, 32, 1, 10, 1, 10, 23, 1, 4, 10, 4, 2, 2, 2, 2, 1, 10, 1, 2, 2, 32, 23, 23]

# Первый код, который приходит в голову имеет вид:
numbers = [9, 8, 32, 1, 10, 1, 10, 23, 1, 4, 10, 4, 2, 2, 2, 2, 1, 10, 1, 2, 2, 32, 23, 23]
result = {}
for num in numbers:
    result[num] += 1

# Однако, просто так сделать result[num] += 1 нельзя, так как если ключа num в словаре еще нет, то возникнет ошибка
# KeyError.
numbers = [9, 8, 32, 1, 10, 1, 10, 23, 1, 4, 10, 4, 2, 2, 2, 2, 1, 10, 1, 2, 2, 32, 23, 23]
result = {}
for num in numbers:
    if num not in result:
        result[num] = 1
    else:
        result[num] += 1

# Цикл for перебирает все элементы списка numbers и для каждого проверяет, присутствует ли он уже в качестве ключа в
# словаре result. Если значение отсутствует, значит число встретилось впервые и мы инициируем значение result[num] = 1.
# Если значение уже присутствует в словаре, увеличим result[num] на единицу.
# Этот код можно улучшить с помощью метода get().


# Метод get()
# Мы можем получить значение в словаре по ключу с помощью индексации, то есть квадратных скобок. Однако как мы знаем,
# в случае отсутствия ключа будет происходить ошибка KeyError.
info = {'name': 'Bob',
        'age': 25,
        'job': 'Dev'}
print(info['name'])  # Bob
# print(info['salary'])  # приводит к возникновению ошибки: KeyError: 'salary'

# Для того, чтобы избежать возникновения ошибки в случае отсутствия ключа в словаре можно использовать метод get(),
# способный кроме ключа принимать и второй аргумент — значение, которое вернется, если заданного ключа нет. Когда второй
# аргумент не указан, то метод в случае отсутствия ключа возвращает None.
info = {'name': 'Bob',
        'age': 25,
        'job': 'Dev'}
item1 = info.get('salary')
item2 = info.get('salary', 'Информации о зарплате нет')
print(item1)  # None
print(item2)  # Информации о зарплате нет

# С помощью словарного метода get(), можно упростить код в задаче о повторяющихся числах.
numbers = [9, 8, 32, 1, 10, 1, 10, 23, 1, 4, 10, 4, 2, 2, 2, 2, 1, 10, 1, 2, 2, 32, 23, 23]
result = {}
for num in numbers:
    result[num] = result.get(num, 0) + 1

# Цикл for перебирает все элементы списка numbers и для каждого элемента с помощью метода get() мы получаем либо его
# значение из словаря result, либо значение по умолчанию, равное 00. К данному значению прибавляется единица, и
# результат записывается обратно в словарь по нужному ключу.


# Метод update()
# Метод update() – реализует своеобразную операцию конкатенации для словарей. Он объединяет ключи и значения одного
# словаря с ключами и значениями другого. При совпадении ключей в итоге сохранится значение словаря, указанного в
# качестве аргумента метода update().
info1 = {'name': 'Bob',
        'age': 25,
        'job': 'Dev'}
info2 = {'age': 30,
        'city': 'New York',
        'email': 'bob@web.com'}
info1.update(info2)
print(info1)  # {'name': 'Bob', 'age': 30, 'job': 'Dev', 'city': 'New York', 'email': 'bob@web.com'}

# В Python 3.9 появились операторы | и |= которые реализуют операцию конкатенации словарей.
info1 = {'name': 'Bob',
        'age': 25,
        'job': 'Dev'}
info2 = {'age': 30,
        'city': 'New York',
        'email': 'bob@web.com'}
info1 |= info2
print(info1)  # {'name': 'Bob', 'age': 30, 'job': 'Dev', 'city': 'New York', 'email': 'bob@web.com'}


# Метод setdefault()
# Метод setdefault() позволяет получить значение из словаря по заданному ключу, автоматически добавляя элемент словаря,
# если он отсутствует.
# Метод принимает два аргумента:
#     * key: ключ, значение по которому следует получить, если таковое имеется в словаре, либо создать.
#     * default: значение, которое будет использовано при добавлении нового элемента в словарь.
# В зависимости от значений параметров key и default возможны следующие сценарии работы данного метода.

# Сценарий 1. Если ключ key присутствует в словаре, то метод возвращает значение по заданному ключу (независимо от того,
# передан параметр default или нет).
info = {'name': 'Bob',
        'age': 25}
name1 = info.setdefault('name')           # параметр default не задан
name2 = info.setdefault('name', 'Max')    # параметр default задан
print(name1)  # Bob
print(name2)  # Bob

# Сценарий 2. Если ключ key отсутствует в словаре, то метод вставляет переданное значение default по заданному ключу.
info = {'name': 'Bob',
        'age': 25}
job = info.setdefault('job', 'Dev')
print(info)  # {'name': 'Bob', 'age': 25, 'job': 'Dev'}
print(job)   # Dev

# При этом если значение default не передано в метод, то вставится значение None.
info = {'name': 'Bob',
        'age': 25}
job = info.setdefault('job')
print(info)  # {'name': 'Bob', 'age': 25, 'job': None}
print(job)   # None


# Удаление элементов из словаря
# Существует несколько способов удаления элементов из словаря:
#     * оператор del;
#     * метод pop();
#     * метод popitem();
#     * метод clear().


# Оператор del
# С помощью оператора del можно удалять элементы словаря по определенному ключу.
info = {'name': 'Sam',
        'age': 28,
        'job': 'Teacher',
        'email': 'timyr-guev@yandex.ru'}
del info['email']    # удаляем элемент имеющий ключ email
del info['job']      # удаляем элемент имеющий ключ job
print(info)          # {'name': 'Sam', 'age': 28}
# Если удаляемого ключа в словаре нет, возникнет ошибка KeyError.


# Метод pop()
# Оператор del удаляет из словаря элемент по заданному ключу вместе с его значением. Если требуется получить само
# значение удаляемого элемента, то нужен метод pop().
info = {'name': 'Sam',
        'age': 28,
        'job': 'Teacher',
        'email': 'timyr-guev@yandex.ru'}
email = info.pop('email')          # удаляем элемент по ключу email, возвращая его значение
job = info.pop('job')              # удаляем элемент по ключу job, возвращая его значение
print(email)  # timyr-guev@yandex.ru
print(job)    # Teacher
print(info)   # {'name': 'Sam', 'age': 28}

# Единственное отличие этого способа удаления от оператора del — он возвращает удаленное значение. В остальном этот
# способ идентичен оператору del. В частности, если удаляемого ключа в словаре нет, возникнет ошибка KeyError.

# Чтобы ошибка не появлялась, этому методу можно передать второй аргумент. Он будет возвращен, если указанного ключа в
# словаре нет. Это позволяет реализовать безопасное удаление элемента из словаря:
surname = info.pop('surname', None)

# Если ключа surname в словаре нет, то в переменной surname будет храниться значение None.

# Метод popitem()
# Метод popitem() удаляет из словаря последний добавленный элемент и возвращает удаляемый элемент в виде кортежа
# (ключ, значение).
info = {'name': 'Bob', 'age': 25, 'job': 'Dev'}
info['surname'] = 'Sinclar'
item = info.popitem()
print(item)  # ('surname', 'Sinclar')
print(info)  # {'name': 'Bob', 'age': 25, 'job': 'Dev'}

# В версиях Python ниже 3.6 метод popitem() удалял случайный элемент.


# Метод clear()
# Метод clear() удаляет все элементы из словаря.
info = {'name': 'Bob',
        'age': 25,
        'job': 'Dev'}
info.clear()
print(info)  # {}


# Метод copy()
# Метод copy() создает поверхностную копию словаря.
info = {'name': 'Bob',
        'age': 25,
        'job': 'Dev'}
info_copy = info.copy()
print(info_copy)  # {'name': 'Bob', 'age': 25, 'job': 'Dev'}

# Не стоит путать копирование словаря (метод copy()) и присвоение новой переменной ссылки на старый словарь.
info = {'name': 'Bob',
        'age': 25,
        'job': 'Dev'}
new_info = info
new_info['name'] = 'Tim'
print(info)  # {'name': 'Tim', 'age': 25, 'job': 'Dev'}

# Оператор присваивания (=) не копирует словарь, а лишь присваивает ссылку на старый словарь новой переменной.

# Таким образом, когда мы изменяем словарь new_info, меняется и словарь info. Если необходимо изменить один словарь,
# не изменяя второй, используют метод copy().
info = {'name': 'Bob',
        'age': 25,
        'job': 'Dev'}
new_info = info.copy()
new_info['name'] = 'Tim'
print(info)      # {'name': 'Bob', 'age': 25, 'job': 'Dev'}
print(new_info)  # {'name': 'Tim', 'age': 25, 'job': 'Dev'}


# Примечания
# Примечание 1. Словарь можно использовать вместо нескольких вложенных условий, если вам нужно проверить число на
# равенство. Например вместо
num = int(input())
if num == 1:
    description = 'One'
elif num == 2:
    description = 'Two'
elif num == 3:
    description = 'Three'
else:
    description = 'Unknown'
print(description)

# можно написать
num = int(input())
description = {1: 'One', 2: 'Two', 3: 'Three'}
print(description.get(num, 'Unknown'))

# На практике, такой код встречается достаточно часто. Особенно если в программе необходимо часто осуществлять проверку
# указанного типа.
