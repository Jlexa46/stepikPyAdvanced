# Позиция в файле
# Когда мы читаем текст из файла с помощью методов read() или readlines() происходит перемещение текущей позиции в конец
# файла. При использовании метода readline() текущая позиция перемещается на следующую строку файла.

# При открытии файла текущая позиция всегда равна нулю – указывает на первый символ текста. При прочтении файла до конца
# с помощью вызова методов read(), readlines() позиция перемещается в конец файла и последующие чтения ничего не дают.

# Вызов методов read(), readlines(), readline() перемещает текущую позицию туда, где завершилось чтение. Для методов
# read() и readlines() это конец файла, для метода readline() – следующая строка после прочитанной.

# Текущую позицию обычно называют "курсор".

# Предположим, у нас есть файл languages.txt. Когда мы его открываем, курсор находится в начале файла, в нулевой позиции
# Если мы считаем две строки с помощью метода readline():
file = open('languages.txt', 'r', encoding='utf-8')
line1 = file.readline()
line2 = file.readline()
file.close()

# курсор переместится в начало третьей строки

# Чтение всегда происходит слева направо от курсора. Таким образом, если после двух вызовов метода readline() вызвать
# метод read(), он считает не весь файл, а только оставшиеся строки:
file = open('languages.txt', 'r', encoding='utf-8')
line1 = file.readline()
line2 = file.readline()
remaining_lines = file.read()    # считывание начинается с 3 строки до конца файла
file.close()

# После того, как мы считали все строки файла, курсор находится в конце.

# После завершения чтения мы больше не можем считать ни одного символа из файла. Все последующие вызовы методов read()
# или readline() будут приводить к считыванию пустой строки.

# Для повторного чтения данных из файла, можно:
#     переоткрыть файл, тогда курсор снова попадёт в начало;
#     переместить курсор с помощью файлового метода seek().


# Файловый метод seek()
# Файловый метод seek() задаёт позицию курсора в байтах от начала файла. Чтобы перевести курсор в самое начало файла
# необходимо вызвать метод seek(), передав ему в качестве аргумента значение 0.
file = open('languages.txt', 'r', encoding='utf-8')
line1 = file.readline()
file.seek(0)               # переводим курсор в самое начало
line2 = file.readline()
print(line1, line2)  # Python Python
file.close()

# Метод seek() не очень полезен при работе с текстовыми файлами, так как не учитывает разделение текста на строки.
# А вот при работе с файлами в двоичном режиме умение работать с позицией и смещениями очень важно!

# Будьте аккуратны с символами, использующими более 11 байта (кириллица в кодировке utf-8), обращение к "промежуточному"
# байту может вызвать ошибку.

# Если метод seek() устанавливает курсор (текущую позицию), то метод tell() получает ее.
file = open('languages.txt', 'r', encoding='utf-8')
print(file.tell())  # 0
line1 = file.readline()
print(file.tell())  # 8
file.close()

# В самом начале курсор (текущая позиция) равен нулю, после считывания первой строки, курсор смещается на 88 байт
# (по байту на каждый из символов 'P', 'y', 't', 'h', 'o', 'n' и два байта на символ перевода строки '\n').


# Менеджер контекста
# Как уже сказано, важно своевременно закрывать файлы с помощью метода close(). Закрытие файлов вручную, а также отдача
# закрытия на откуп среде исполнения, обладают существенным недостатком: если между открытием файла и его закрытием
# произойдёт ошибка, в лучшем случае файл окажется открыт слишком долго, а в худшем случае часть данных не сохранится.

# Хочется иметь возможность автоматически закрывать файл сразу после окончания работы с ним и осуществлять закрытие даже
# при возникновении ошибки. Файловые объекты уже умеют работать в таком режиме, но для этого их нужно использовать как
# менеджеры контекста.

# Менеджер контекста — объект, реализующий одноименный протокол. Объекты, реализующие этот протокол, позволяют
# использовать следующий специальный синтаксис:
with object as name:
    pass
    # Здесь нам доступен ресурс name.
    # Это тело with-блока.
# А здесь ресурс name уже освобождён, даже если в теле with-блока произошла ошибка.

# Весь код в теле with-блока работает "в контексте". Чаще всего контекст подразумевает выделение некоего ресурса,
# например, файла. По выходу из контекста ресурс автоматически освобождается, даже если при выполнении блока возникло
# исключение.

# Как только закончится код, оформленный с отступами в with (аналогичные отступы в циклах или функциях), это будет
# означать, что контекст закончился, и Python автоматически закроет файл.

# Приведенный ниже код:
file = open('languages.txt', 'r', encoding='utf-8')
for line in file:
    print(line)
file.close()              # ручное закрытие файла
print('Файл закрыт')

# можно переписать в виде:
with open('languages.txt', 'r', encoding='utf-8') as file:
    for line in file:
        print(line)
                          # автоматическое закрытие файла
print('Файл закрыт')

# Обратите внимание: при использовании менеджера контекста не требуется использовать метод close().

# При работе с файлами желательно всегда использовать менеджер контекста. Это делает программу надежнее.


# Примечания
# Примечание 1. Подробнее о файловом методе seek() можно почитать в документации.
# https://docs.python.org/3/library/io.html#io.TextIOBase.seek

# Примечание 2. В современных операционных системах файловый ввод-вывод устроен достаточно сложно. Для обеспечения
# максимального быстродействия чтения и записи в файлы, а также контроля безопасности этого процесса, большинство
# операционных систем не позволяют программам напрямую работать с диском. Операционная система предоставляет программам
# специальные объекты — файловые дескрипторы (функция open() возвращает как раз файловый дескриптор). Имея файловый
# дескриптор, можно записывать и читать данные, не задумываясь о файловой системе. Файловые дескрипторы удобны, но на
# создание каждого расходуется достаточно большое количество ресурсов. Поэтому у операционной системы есть общий лимит
# на количество одновременно использующихся файловых дескрипторов. И при этом каждая программа имеет свой собственный
# лимит. Как только программа исчерпает доступное ей количество дескрипторов, следующая попытка открыть очередной файл
# закончится с ошибкой. Программисту важно следить за тем, сколько файлов программа открывает в каждый момент и
# закрывает ли она их своевременно. Используйте менеджер контекста with и жизнь станет проще.

# Примечание 3. С помощью менеджера контекста можно работать с несколькими файлами.
with open('input.txt', 'r') as input_file, open('output.txt', 'w') as output_file:
    pass # обработка файлов
