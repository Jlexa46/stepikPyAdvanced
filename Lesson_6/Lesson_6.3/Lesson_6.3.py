# Перебор кортежей
# Перебор элементов кортежа осуществляется точно так же как перебор элементов списка.
# Для вывода каждого из элементов кортежа на отдельной строке можно использовать следующий код:
# Вариант 1. Если нужны индексы элементов:
numbers = (0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10)
for i in range(len(numbers)):
    print(numbers[i])

# Вариант 2. Если индексы не нужны:
numbers = (0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10)
for num in numbers:
    print(num)

# Можно также использовать операцию распаковки кортежа.
numbers = (0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10)
languages = ('Python', 'C++', 'Java')
print(*numbers)
print(*languages, sep='\n')

# Сравнение кортежей
# Кортежи можно сравнивать между собой.
print((1, 8) == (1, 8))             # True
print((1, 8) != (1, 10))            # True
print((1, 9) < (1, 2))              # False
print((2, 5) < (6,))                # True
print(('a', 'bc') > ('a', 'de'))    # False

# Обратите внимание: операции == и != применимы к любым кортежам, независимо от типов элементов.
# А вот операции <, >, <=, >= применимы только в том случае, когда соответствующие элементы кортежей имеют один тип.
print((7, 5) < ('java', 'python'))  # TypeError: '<' not supported between instances of 'int' and 'str'

# Сравнение кортежей происходит последовательно элемент за элементом, а если элементы равны — просматривается следующий
# элемент.


# Сортировка кортежей
# Как мы помним, списки имеют метод sort(), который осуществляет сортировку на месте, то есть меняет порядок исходного
# списка. Поскольку кортежи по своей природе неизменяемы, то встроенного метода sort() они не содержат, тем не менее с
# помощью встроенной функции sorted() (не путать с списочным методом sort()) мы можем сортировать значения в кортежах.
not_sorted_tuple = (34, 1, 8, 67, 5, 9, 0, 23)
print(not_sorted_tuple)  # (34, 1, 8, 67, 5, 9, 0, 23)
sorted_tuple = tuple(sorted(not_sorted_tuple))
print(sorted_tuple)      # (0, 1, 5, 8, 9, 23, 34, 67)

# Обратите внимание, что функция sorted() возвращает список, но с помощью функции tuple() мы приводим результат
# сортировки к кортежу.

# Для сортировки кортежа можно воспользоваться явным преобразованием в список и использовать метод sort():
not_sorted_tuple = ('cc', 'aa', 'dd', 'bb')
tmp = list(not_sorted_tuple)
tmp.sort()
sorted_tuple = tuple(tmp)
print(sorted_tuple)


# Преобразование кортежа в список и строку
# Часто на практике нам приходится преобразовывать кортежи в списки и в строки. Для этого используются функции и методы
# str(), list(), tuple(), join().

# Преобразование кортежа в список и наоборот
# Кортеж можно преобразовать в список с помощью функции list().
tuple1 = (1, 2, 3, 4, 5)
list1 = list(tuple1)
print(list1)  # [1, 2, 3, 4, 5]

# Список можно преобразовать в кортеж с помощью функции tuple().
list1 = [1, 17.8, 'Python']
tuple1 = tuple(list1)
print(tuple1)  # (1, 17.8, 'Python')

# Преобразование кортежа в строку и наоборот
# Кортеж можно преобразовать в строку с помощью строкового метода join().
notes = ('Do', 'Re', 'Mi', 'Fa', 'Sol', 'La', 'Si')
string1 = ''.join(notes)
string2 = '.'.join(notes)
print(string1)  # DoReMiFaSolLaSi
print(string2)  # Do.Re.Mi.Fa.Sol.La.Si

# Обратите внимание, что для применения строкового метода join() кортеж должен содержать именно строковые элементы.
# Если элементы кортежа отличны от строк, то требуется предварительно их преобразовать.

# Строку можно преобразовать в кортеж с помощью функции tuple().
letters = 'abcdefghijkl'
tpl = tuple(letters)
print(tpl)  # ('a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l')


# Упаковка кортежей
# Упаковкой кортежа называют присваивание его какой-либо переменной.
tuple1 = (1, 2, 3)
tuple2 = ('b',)
tuple3 = ('red', 'green', 'blue', 'cyan')
print(type(tuple1))  # <class 'tuple'>
print(type(tuple2))  # <class 'tuple'>
print(type(tuple3))  # <class 'tuple'>

# Обратите внимание на то, что упаковка выполняется всегда, когда справа от знака равенства стоит больше одного значения.
tuple1 = 1, 2, 3
tuple2 = 'b',
print(type(tuple1))  # <class 'tuple'>
print(type(tuple2))  # <class 'tuple'>


# Распаковка кортежей
# Обратная операция, смысл которой в том, чтобы присвоить значения элементов кортежа отдельным переменным называется
# распаковкой кортежа.
colors = ('red', 'green', 'blue', 'cyan')
(a, b, c, d) = colors
print(a)  # red
print(b)  # green
print(c)  # blue
print(d)  # cyan

# Мы можем опустить скобки слева от знака равенства:
colors = ('red', 'green', 'blue', 'cyan')
a, b, c, d = colors

# Количество переменных должно совпадать с числом элементов в кортеже.
colors = ('red', 'green', 'blue', 'cyan')
# a, b = colors  # ValueError: too many values to unpack

# Аналогично, приведенный ниже код:
colors = ('red', 'green', 'blue')
# a, b, c, d = colors  # ValueError: not enough values to unpack (expected 4, got 3)

# Однако, если необходимо получить лишь какие-то отдельные значения, то в качестве "ненужных" переменных позволено
# использовать символ нижнего подчеркивания _.
colors = ('red', 'green', 'blue')
a, b, _ = colors
print(a)  # red
print(b)  # green

# Распаковка кортежей очень удобна на практике. По сути мы использовали ее, когда меняли местами значения двух
# переменных без использования временных переменных.
a = 7
b = 17
a, b = b, a
print(a, b)  # 17 7


# * при распаковке кортежей
# Как мы знаем, если при распаковке кортежа число элементов слева и справа не совпадает, то возникает ошибка времени
# исполнения. Есть способ собрать сразу несколько значений в одну переменную. Это делается при помощи звездочки перед
# именем переменной.

a, b, *tail = 1, 2, 3, 4, 5, 6
# В этом случае в переменной a будет записана единица, в переменной b — двойка, а в переменной tail — список, состоящий
# из всех аргументов, которые не попали в предыдущие переменные. В данном случае tail будет равен [3, 4, 5, 6].
# Учтите, что tail всегда будет списком, даже когда в него попадает лишь один элемент или даже ноль.
a, b, *tail = 1, 2, 3
print(tail)  # [3]

a, b, *tail = 1, 2
print(tail)  # []

# Звездочка может быть только у одного аргумента, но необязательно у последнего.
*names, surname = ('Стефани', 'Джоанн', 'Анджелина', 'Джерманотта')
print(names)    # ['Стефани', 'Джоанн', 'Анджелина']
print(surname)  # Джерманотта

# Аргумент со звездочкой может стоять и посередине.
singer = ('Freddie', 'Bohemian Rhapsody', 'Killer Queen', 'Love of my life', 'Mercury')
name, *songs, surname = singer
print(name)     # Freddie
print(songs)    # ['Bohemian Rhapsody', 'Killer Queen', 'Love of my life']
print(surname)  # Mercury


# Примечания
# Примечание 1. Если вы хотите распаковать единственное значение в кортеже, после имени переменной должна идти запятая.
a = 1,      # не распаковка, а просто присвоение
b, = 1,     # распаковка
print(a)    # (1,)
print(b)    # 1

# Примечание 2. Распаковывать можно не только кортеж, правая сторона может быть любой последовательностью
# (кортеж, строка или список).
info = ['timur', 'beegeek.org']
user, domain = info    # распаковка списка
print(user)    # timur
print(domain)  # beegeek.org
a, b, c, d = 'math'    # распаковка строки
print(a)    # m
print(b)    # a
print(c)    # t
print(d)    # h

# Примечание 3. Помимо метода split() строковый тип данных содержит метод partition(). Метод partition() принимает на
# вход один аргумент sep, разделяет строку при первом появлении sep и возвращает кортеж, состоящий из трех элементов:
# часть перед разделителем, сам разделитель и часть после разделителя. Если разделитель не найден, то кортеж содержит
# саму строку, за которой следуют две пустые строки.
s1 = 'abc-de'.partition('-')
s2 = 'abc-de'.partition('.')
s3 = 'abc-de-fgh'.partition('-')
print(s1)   # ('abc', '-', 'de')
print(s2)   # ('abc-de', '', '')
print(s3)   # ('abc', '-', 'de-fgh')

# Примечание 4. С использованием кортежей многие алгоритмы приобретают достаточно краткую форму. Например, вычисление
# чисел Фибоначчи может выглядеть следующим образом:
n = int(input())
f1, f2 = 1, 1
for i in range(n):
    print(f1)
    f1, f2 = f2, f1 + f2

# Примечание 5. Замечательная серия статей о коллекциях (list, tuple, str, set, dict) в Python.
# https://habr.com/ru/post/319164/
