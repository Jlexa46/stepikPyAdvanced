# Переменное количество аргументов
# Вспомним функцию print(), которой мы пользуемся почти в каждой задаче.
print('a')                  # a
print('a', 'b')             # a b
print('a', 'b', 'c')        # a b c
print('a', 'b', 'c', 'd')   # a b c d

# Функция print() принимает столько аргументов, сколько ей передано. Причем функция print() делает полезную работу, даже
# когда вызывается вообще без аргументов. В этом случае она переносит каретку печати на новую строку.

# Было бы здорово научиться писать свои собственные функции, способные принимать переменное количество аргументов. Для
# этого потребуется специальный, совсем не сложный во всех смыслах, синтаксис.

# Рассмотрим определение функции my_func():
def my_func(*args):
    print(type(args))
    print(args)
my_func()           # <class 'tuple'> ()
my_func(1, 2, 3)    # <class 'tuple'> (1, 2, 3)
my_func('a', 'b')   # <class 'tuple'> ('a', 'b')

# В заголовке функции my_func() указан всего один параметр args, но со звездочкой перед ним. Звездочка в определении
# функции означает, что переменная (параметр) args получит в виде кортежа все аргументы, переданные в функцию при ее
# вызове от текущей позиции и до конца.

# При описании функции можно использовать только один параметр помеченный звездочкой, причем располагаться он должен в
# конце списка параметров, иначе последующим параметрам не достанется значений.

# Приведенный ниже код не является рабочим, так как параметр со звездочкой указан раньше позиционного num.
def my_func(*args, num):
    print(args)
    print(num)

# Приведенный ниже код связывает с переменной num значение 17, а с переменной args значение кортежа ('Python', 2, 'C#')
# и выводит:
def my_func(num, *args):
    print(args)
    print(num)
my_func(17, 'Python', 2, 'C#')  # ('Python', 2, 'C#') 17

# Помеченный звездочкой параметр *args нормально переживает и отсутствие аргументов, в то время как позиционные
# параметры всегда обязательны.

# Приведенный ниже код связывает с переменной num значение 17,а с переменной args значение пустого кортежа () и выводит:
my_func(17)  # () 17

# Обратите внимание: функция my_func() принимает несколько аргументов, но как минимум один аргумент должен быть передан
# обязательно. Этот первый аргумент станет значением переменной num, а остальные аргументы сохранятся в переменной args.
# Подобным образом можно делать любое количество обязательных аргументов.

# Параметр args в определении функции пишется после позиционных параметров перед первым параметром со значением по
# умолчанию.


# Передача аргументов в форме списка и кортежа
# Иногда хочется сначала сформировать набор аргументов, а потом передать их функции. Тут поможет оператор распаковки
# коллекций, который также обозначается звездочкой *.

# Вспомним, что встроенная функция sum() принимает на вход коллекцию чисел (список, кортеж, и т.д).
sum1 = sum([1, 2, 3, 4])        # считаем сумму чисел в списке
sum2 = sum((10, 20, 30, 40))    # считаем сумму чисел в кортеже
print(sum1, sum2)   # 10 100

# Однако функция sum() не может принимать переменное количество аргументов.

# Приведенный ниже код приводит к возникновению ошибки:
sum1 = sum(1, 2, 3, 4)
print(sum1)  # TypeError: sum expected at most 2 arguments, got 4

# Напишем свою версию функции sum(), функцию my_sum(), которая принимает переменное количество аргументов и вычисляет их
# сумму:
def my_sum(*args):
    return sum(args)    # args - это кортеж
print(my_sum())             # 0
print(my_sum(1))            # 1
print(my_sum(1, 2))         # 3
print(my_sum(1, 2, 3))      # 6
print(my_sum(1, 2, 3, 4))   # 10

# Мы также можем вызывать нашу функцию my_sum() , передавая ей списки или кортежи, предварительно распаковав их.
print(my_sum(*[1, 2, 3, 4, 5]))   # 15 распаковка списка
print(my_sum(*(1, 2, 3)))         # 6 распаковка кортежа

# Более того, часть аргументов можно передавать непосредственно и даже коллекции подставлять не только по одной.
print(my_sum(1, 2, *[3, 4, 5], *(7, 8, 9), 10))  # 49

# По соглашению, параметр, получающий подобный кортеж значений, принято называть args (от слова arguments). Старайтесь
# придерживаться этого соглашения.


# Получение именованных аргументов в виде словаря
# Позиционные аргументы можно получать в виде *args, причём произвольное их количество. Такая возможность существует и
# для именованных аргументов. Только именованные аргументы получаются в виде словаря, что позволяет сохранить имена
# аргументов в ключах.
def my_func(**kwargs):
    print(type(kwargs))
    print(kwargs)
my_func()                               # <class 'dict'> {}
my_func(a=1, b=2)                       # <class 'dict'> {'a': 1, 'b': 2}
my_func(name='Timur', job='Teacher')    # <class 'dict'> {'name': 'Timur', 'job': 'Teacher'}

# По соглашению параметр, получающий подобный словарь, принято называть kwargs (от словосочетания keyword arguments).
# Старайтесь придерживаться этого соглашения.

# Параметр  **kwargs пишется в самом конце, после последнего аргумента со значением по умолчанию. При этом функция может
# содержать и *args и **kwargs параметры.
# Рассмотрим определение функции, которая принимает все виды аргументов.
def my_func(a, b, *args, name='Gvido', age=17, **kwargs):
    print(a, b)
    print(args)
    print(name, age)
    print(kwargs)
my_func(1, 2, 3, 4, name='Timur', age=28, job='Teacher', language='Python')
my_func(1, 2, name='Timur', age=28, job='Teacher', language='Python')
my_func(1, 2, 3, 4, job='Teacher', language='Python')

# Не нужно пугаться, в реальном коде функции редко используют все эти возможности одновременно. Но понимать, как каждая
# отдельная форма объявления аргументов работает, и как такие формы сочетать — очень важно.

# Для лучшего понимания, поэкспериментируйте с передачей аргументов. Правила использования аргументов довольно сложно
# описывать, но на практике мы редко сталкиваемся с проблемами.


# Передача именованных аргументов в форме словаря
# Как и в случае позиционных аргументов, именованные можно передавать в функцию "пачкой" в виде словаря. Для этого нужно
# перед словарём поставить две звёздочки.
def my_func(**kwargs):
    print(type(kwargs))
    print(kwargs)
info = {'name':'Timur', 'age':'28', 'job':'teacher'}
my_func(**info)  # <class 'dict'> {'name': 'Timur', 'age': '28', 'job': 'teacher'}

# Рассмотрим еще один пример определения функции print_info(), распечатывающей информацию о пользователе.
def print_info(name, surname, age, city, *children, **additional_info):
    print('Имя:', name)
    print('Фамилия:', surname)
    print('Возраст:', age)
    print('Город проживания:', city)
    if len(children) > 0:
        print('Дети:', ', '.join(children))
    if len(additional_info) > 0:
        print(additional_info)
children = ['Бодхи Рансом Грин', 'Ноа Шэннон Грин', 'Джорни Ривер Грин']
additional_info = {'height':163, 'job':'actress'}
print_info('Меган', 'Фокс', 34, 'Ок-Ридж', *children, **additional_info)

# При подстановке аргументов "разворачивающиеся" наборы аргументов вроде *positional и **named можно указывать
# вперемешку с аргументами соответствующего типа: *positional с позиционными, а **named — с именованными. И, конечно,
# же, все именованные аргументы должны идти после всех позиционных!


# Keyword-only аргументы
# В Python 3 добавили возможность пометить именованные аргументы функции так, чтобы вызвать функцию можно было, только
# передав эти аргументы по именам. Такие аргументы называются keyword-only и их нельзя передать в функцию в виде
# позиционных.
def make_circle(x, y, radius, *, line_width=1, fill=True):
    pass

# Здесь * выступает разделителем: отделяет обычные аргументы (их можно указывать по имени и позиционно) от строго
# именованных.

# Приведенный ниже код работает как и полагается:
make_circle(10, 20, 5)                                     # x=10, y=20, radius=5,  line_width=1, fill=True
make_circle(x=10, y=20, radius=7)                          # x=10, y=20, radius=7,  line_width=1, fill=True
make_circle(10, 20, radius=10, line_width=2, fill=False)   # x=10, y=20, radius=10, line_width=2, fill=False
make_circle(x=10, y=20, radius=17, line_width=3)           # x=10, y=20, radius=17, line_width=3, fill=True

# То есть аргументы x, y и radius могут быть переданы в качестве как позиционных, так и именованных аргументов. При этом
# аргументы line_width и fill могут быть переданы только как именованные аргументы.

# Приведенный ниже код приводит к возникновению ошибок.
# make_circle(10, 20, 15, 20)
# make_circle(x=10, y=20, 15, True)
# make_circle(10, 20, 10, 2, False)

# Этот пример неплохо демонстрирует подход к описанию аргументов. Первые три аргумента — координаты центра круга и
# радиус. Координаты центра и радиус присутствуют у круга всегда, поэтому обязательны и их можно не именовать. А вот
# line_width и fill — необязательные аргументы, ещё и получающие ничего не говорящие значения. Вполне логично ожидать,
# что вызов вида make_circle(10, 20, 5, 3, False) мало кому понравится! Ради ясности аргументы line_width и fill  и
# объявлены так, что могут быть указаны только явно через имя.

# Мы также можем объявить функцию, у которой будут только строго именованные аргументы, для этого нужно поставить
# звёздочку в самом начале перечня аргументов.
def make_circle(*, x, y, radius, line_width=1, fill=True):
    pass

# Теперь для вызова функции make_circle() нам нужно передать значения всех аргументов явно через их имя:
make_circle(x=10, y=20, radius=15)                              # line_width=1, fill=True
make_circle(x=10, y=20, radius=15, line_width=4, fill=False)

# Такой разделитель можно использовать только один раз в определении функции. Его нельзя применять в функциях с
# неограниченным количеством позиционных аргументов *args.


# Примечания.
# Примечание 1. Специальный синтаксис *args и **kwargs в определении функции позволяет передавать функции переменное
# количество позиционных и именованных аргументов. При этом args и kwargs просто имена. Вы не обязаны их использовать,
# можно выбрать любые, однако среди Python программистов приняты именно эти.

# Примечание 2. Вы можете использовать одновременно *args и **kwargs в одной строке для вызова функции. В этом случае
# порядок имеет значение. Как и аргументы, не являющиеся аргументами по умолчанию, *args должны предшествовать и
# аргументам по умолчанию, и **kwargs. Правильный порядок параметров:
#     1. позиционные аргументы,
#     2. *args аргументы,
#     3. **kwargs аргументы.
def my_func(a, b, *args, **kwargs):
    pass









