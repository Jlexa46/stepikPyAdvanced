# Функции all() и any()
# При работе с коллекциями часто приходится определять, выполняется ли некоторое условие одновременно для всех элементов
# последовательности или хотя бы для одного. Для этого существуют две встроенные функции all() и any().


# Функция all()
# Встроенная функция all() возвращает значение True, если все элементы переданной ей последовательности (итерируемого
# объекта) истинны (приводятся к значению True), и False в противном случае.
# Сигнатура функции следующая: all(iterable). В качестве iterable может выступать любой итерируемый объект:
#     список;
#     кортеж;
#     строка;
#     множество;
#     словарь и т.д.
print(all([True, True, True]))     # возвращает True, так как все значения списка равны True
print(all([True, True, False]))    # возвращает False, так как не все значения списка равны True

# Напомним, что в Python все следующие значения приводятся к значению False:
#     константы None и False;
#     нули всех числовых типов данных: 0, 0.0, 0j, Decimal(0), Fraction(0, 1);
#     пустые коллекции: '', (), [], {}, set(), range(0).
print(all([1, 2, 3]))               # True
print(all([1, 2, 3, 0, 5]))         # False
print(all([True, 0, 1]))            # False
print(all(('', 'red', 'green')))    # False
print(all({0j, 3+4j}))              # False

# При работе со словарями функция all() проверяет на соответствие параметрам True ключи словаря, а не их значения.
dict1 = {0: 'Zero', 1: 'One', 2: 'Two'}
dict2 = {'Zero': 0, 'One': 1, 'Two': 2}
print(all(dict1))   # False
print(all(dict2))   # True

# Обратите внимание: если переданный итерируемый объект пустой, то функция all() возвращает значение True.
print(all([]))          # True передаем пустой список
print(all(()))          # True передаем пустой кортеж
print(all(''))          # True передаем пустую строку
print(all([[], []]))    # False передаем список, содержащий пустые списки


# Функция any()
# Встроенная функция any() возвращает значение True, если хотя бы один элемент переданной ей последовательности
# (итерируемого объекта) является истинным (приводится к значению True), и False в противном случае.
# Сигнатура функции следующая: any(iterable). В качестве iterable может выступать любой итерируемый объект:
#     список;
#     кортеж;
#     строка;
#     множество;
#     словарь и т.д.
print(any([False, True, False]))       # возвращает True, так как есть хотя бы один элемент, равный True
print(any([False, False, False]))      # возвращает False, так как нет элементов, равных True

# Приведенный ниже код выводит:
print(any([0, 0, 0]))           # False
print(any([0, 1, 0]))           # True
print(any([False, 0, 1]))       # True
print(any(['', [], 'green']))   # True
print(any({0j, 3+4j, 0.0}))     # True

# При работе со словарями функция any() проверяет на соответствие True ключи словаря, а не их значения.
dict1 = {0: 'Zero'}
dict2 = {'Zero': 0, 'One': 1}
print(any(dict1))   # False
print(any(dict2))   # True

# Обратите внимание: если переданный объект пуст, то функция any() возвращает значение False.
print(any([]))          # False передаем пустой список
print(any(()))          # False передаем пустой кортеж
print(any(''))          # False передаем пустую строку
print(any([[], []]))    # False передаем список, содержащий пустые списки


# Функции all() и any() в связке с функцией map()
# Функции all() и any() могут быть полезны в комбинации с функцией map(), которая может преобразовывать элементы
# последовательности (итерируемого объекта) к значению True/False в соответствии с неким условием.

# Приведенный ниже код, проверяет, все ли элементы списка numbers больше 10:
numbers = [17, 90, 78, 56, 231, 45, 5, 89, 91, 11, 19]
result = all(map(lambda x: True if x > 10 else False, numbers))
if result:
    print('Все числа больше 10')
else:
    print('Хотя бы одно число меньше или равно 10')  # Хотя бы одно число меньше или равно 10

# так как список numbers содержит число 5, которое не больше чем 10.

# Лямбда функцию, которая преобразует элементы списка numbers в значения True/False можно упростить следующим образом:
result = all(map(lambda x: x > 10, numbers))

# Приведенный ниже код, проверяет, что хотя бы один элемент списка четное число:
numbers = [17, 91, 78, 55, 231, 45, 5, 89, 99, 11, 19]
result = any(map(lambda x: x % 2 == 0, numbers))
if result:
    print('Хотя бы одно число четное')  # Хотя бы одно число четное
else:
    print('Все числа нечетные')

# так как список numbers содержит четное число 78.


# Функция enumerate()
# Встроенная функция enumerate() возвращает кортеж из индекса элемента и самого элемента переданной ей
# последовательности (итерируемого объекта).
# Сигнатура функции следующая: enumerate(iterable, start). В качестве iterable может выступать любой итерируемый объект:
#     список;
#     кортеж;
#     строка;
#     множество;
#     словарь и т.д.

# С помощью необязательного параметра start можно задать начальное значение индекса. По умолчанию значение параметра
# start = 0, то есть счет начинается с нуля.
colors = ['red', 'green', 'blue']
for pair in enumerate(colors):
    print(pair)     # (0, 'red') (1, 'green') (2, 'blue')

# Если счет нужно начать с отличного от нуля числа, то нужно передать значение аргумента start.
colors = ['red', 'green', 'blue']
for pair in enumerate(colors, 100):
    print(pair)     # (100, 'red') (101, 'green') (102, 'blue')

# Обратите внимание, функция enumerate() возвращает не список, а специальный объект, который называется итератором.
# Такой объект похож на список тем, что его можно перебирать циклом for, то есть итерировать. Итератор можно
# преобразовать в список с помощью функции list().
colors = ['red', 'green', 'blue']
pairs = enumerate(colors)
print(pairs)        # <enumerate object at 0x...>
print(list(pairs))  # [(0, 'red'), (1, 'green'), (2, 'blue')]

# Мы также можем использовать распаковку кортежей при итерировании с помощью цикла for.
colors = ['red', 'green', 'blue']
for index, item in enumerate(colors):
    print(index, item)  # 0 red 1 green 2 blue

# Такой код является альтернативой коду:
colors = ['red', 'green', 'blue']
for i in range(len(colors)):
    print(i, colors[i])


# Функция zip()
# Встроенная функция zip() объединяет отдельные элементы из каждой переданной ей последовательности (итерируемого
# объекта) в кортежи.
# Сигнатура функции следующая: zip(*iterables). В качестве iterable может выступать любой итерируемый объект:
#     список;
#     кортеж;
#     строка;
#     множество;
#     словарь и т.д.

# Приведенный ниже код выводит:
numbers = [1, 2, 3]
words = ['one', 'two', 'three']
for pair in zip(numbers, words):
    print(pair)     # (1, 'one') (2, 'two') (3, 'three')

# Функция zip(), как и функция enumerate() возвращает не список, а специальный объект, который называется итератором.
# Такой объект похож на список тем, что его можно перебирать циклом for, то есть итерировать. Итератор можно
# преобразовать в список с помощью функции list().
numbers = [1, 2, 3]
words = ['one', 'two', 'three']
result = zip(numbers, words)
print(result)           # <zip object at 0x...>
print(list(result))     # [(1, 'one'), (2, 'two'), (3, 'three')]

# Мы можем передавать функции zip() сколько угодно итерируемых объектов.
numbers = [1, 2, 3]
words = ['one', 'two', 'three']
romans = ['I', 'II', 'III']
result = zip(numbers, words, romans)
print(list(result))     # [(1, 'one', 'I'), (2, 'two', 'II'), (3, 'three', 'III')]

# Мы можем передать функции zip() даже один итерируемый объект.
numbers = [1, 2, 3]
result = zip(numbers)
print(list(result))     # [(1,), (2,), (3,)]

# Если функции zip() передать итерируемые объекты, имеющие разную длину, то объект с наименьшим количеством элементов
# определяет итоговую длину.
numbers = [1, 2, 3, 4]
words = ['one', 'two']
romans = ['I', 'II', 'III']
result = zip(numbers, words, romans)
print(list(result))     # [(1, 'one', 'I'), (2, 'two', 'II')]


# Частые сценарии использования функции zip()
# Сценарий 1. Функция zip() удобна для создания словарей, когда ключи и значения находятся в разных списках.
keys = ['name', 'age', 'gender']
values = ['Timur', 28, 'male']
info = dict(zip(keys, values))
print(info)     # {'name': 'Timur', 'age': 28, 'gender': 'male'}

# Сценарий 2. Функция zip() удобна для одновременного (параллельного) итерирования сразу по нескольким коллекциям.
name = ['Timur', 'Ruslan', 'Rustam']
age = [28, 21, 19]
for x, y in zip(name, age):
    print(x, y)     # Timur 28 Ruslan 21 Rustam 19


# Примечания
# Примечание 1. Итераторы – важная концепция языка Python. Нужно помнить:
#     итераторы можно обойти циклом for;
#     итератор можно преобразовать в список или кортеж, с помощью функций list() и tuple();
#     итератор можно распаковать с помощью *.

# Примечание 2. Реализация встроенных функций all() и any() выглядит примерно так:
def all(iterable):
    for item in iterable:
       if not item:
           return False
    return True
def any(iterable):
    for item in iterable:
        if item:
            return True
    return False

# Примечание 3. Мы можем использовать одновременно функции zip() и enumerate():
list1 = ['a1', 'a2', 'a3']
list2 = ['b1', 'b2', 'b3']
for index, (item1, item2) in enumerate(zip(list1, list2)):
    print(index, item1, item2)  # 0 a1 b1 1 a2 b2 2 a3 b3