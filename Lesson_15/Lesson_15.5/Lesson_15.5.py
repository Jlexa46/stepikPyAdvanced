# Функции высшего порядка
# Как уже сказано, функции, которые принимают или/и возвращают другие функции, называются функциями высшего порядка.

# Давайте реализуем простейшую функцию высшего порядка:
def high_order_function(func):     # функция высшего порядка, так как принимает функцию
    return func(3)
def double(x):                     # обычная функция = функция первого порядка
    return 2*x
def add_one(x):                    # обычная функция = функция первого порядка
    return x + 1

# Здесь функция high_order_function() принимает другую функцию на входе и возвращает результат её вызова с аргументом,
# равным 3.
print(high_order_function(double))      # 6
print(high_order_function(add_one))     # 4

# Функции первого порядка принимают и возвращают "обычные" значения, не функции, функции высшего порядка принимают или/и
# возвращают другие функции.


# Функции высшего порядка для обработки набора данных
# Часто функции высшего порядка используются для обработки наборов данных.Рассмотрим три важные функции высшего порядка:
#     map();
#     filter();
#     reduce().

# В языке Python эти функции уже реализованы, однако для лучшего понимания их работы мы сначала напишем свои версии этих
# функций, и уже после этого поговорим о встроенных реализациях.

# Функции высшего порядка map(), filter() и reduce() довольно широко распространены в функциональном программировании и
# часто применяются программистами.


# Функция map()
# При работе со списками часто требуется применить одно и то же преобразование к каждому элементу. Можно написать цикл,
# содержащий нужное преобразование.
# Например, для преобразования списка чисел в список их квадратов, код может выглядеть так:
def f(x):
    return x**2     # тело функции, которая преобразует аргумент x
old_list = [1, 2, 4, 9, 10, 25]
new_list = []
for item in old_list:
    new_item = f(item)
    new_list.append(new_item)
print(old_list)     # [1, 2, 4, 9, 10, 25]
print(new_list)     # [1, 4, 16, 81, 100, 625]

# Несложно понять, что цикл будет выглядеть одинаково практически во всех случаях. Меняться будет только преобразование,
# то есть применяемая функция f(). Так почему бы не обобщить код, чтобы функция была параметром? Так и сделаем:
def map(function, items):
    result = []
    for item in items:
        new_item = function(item)
        result.append(new_item)
    return result

# Теперь мы можем совершать преобразования, используя функцию высшего порядка map().
def square(x):
    return x**2
def cube(x):
    return x**3
numbers = [1, 2, -3, 4, -5, 6, -9, 0]
strings = map(str, numbers)        # используем в качестве преобразователя - функцию str
abs_numbers = map(abs, numbers)    # используем в качестве преобразователя - функцию abs
squares = map(square, numbers)     # используем в качестве преобразователя - функцию square
cubes = map(cube, numbers)         # используем в качестве преобразователя - функцию cube
print(strings)      # ['1', '2', '-3', '4', '-5', '6', '-9', '0']
print(abs_numbers)  # [1, 2, 3, 4, 5, 6, 9, 0]
print(squares)      # [1, 4, 9, 16, 25, 36, 81, 0]
print(cubes)        # [1, 8, -27, 64, -125, 216, -729, 0]

# Функция называется "map" то есть "отобразить". Название пришло из математики, где так называется функция, отображающая
# одно множество значений в другое путём преобразования всех элементов с помощью некой трансформации.

# Реализованную нами функцию map() можно использовать как альтернативную возможность для преобразования типов элементов
# любого списка. Раньше мы решали такую задачу с помощью списочных выражений. Теперь можем использовать и функцию map().

# Приведенный ниже код, при условии, что функция map() определена как указано выше:
strings = ['10', '12', '-4', '-9', '0', '1', '23', '100', '99']
numbers1 = [int(str) for str in strings]   # используем списочное выражение для преобразования
numbers2 = map(int, strings)               # используем функцию map() для преобразования
print(numbers1)  # [10, 12, -4, -9, 0, 1, 23, 100, 99]
print(numbers2)  # [10, 12, -4, -9, 0, 1, 23, 100, 99]


# Цепочки преобразований
# Мы также можем строить цепочки преобразований, несколько раз вызывая функцию map().
# Приведенный ниже код, при условии, что функция map() определена как указано выше:
numbers = ['-1', '20', '3', '-94', '65', '6', '-970', '8']
new_numbers = map(abs, map(int, numbers))
print(new_numbers)  # [1, 20, 3, 94, 65, 6, 970, 8]

# То есть, сначала мы преобразуем список строк в список чисел с помощью кода map(int, numbers), получая список
# [-1, 20, 3, -94, 65, 6, -970, 8]. Далее с помощью еще одного вызова функции map() трансформируем полученный список в
# список [1, 20, 3, 94, 65, 6, 970, 8].


# Функция filter()
# Другая популярная задача при работе со списками: отобрать часть элементов списка по определенному критерию. Функция
# высшего порядка для решения такой задачи называется filter().

# Функция-критерий, которая возвращает значение True или False, называется предикатом.

# Реализация такой функции может выглядеть так:
def filter(function, items):
    result = []
    for item in items:
        if function(item):
            result.append(item)  # добавляем элемент item если функция function вернула значение True
    return result

# Наша функция filter() применяет предикат function к каждому элементу и добавляет в итоговый список только те элементы,
# для которых предикат вернул True.

# Например, чтобы из исходного списка чисел получить список с элементами, большими 10, можно написать такой код:
def is_greater10(num):   # функция возвращает значение True если число больше 10 и False в противном случае
    return num > 10
numbers = [12, 2, -30, 48, 51, -60, 19, 10, 13]
large_numbers = filter(is_greater10, numbers)   #  список large_numbers содержит элементы, большие 10
print(large_numbers)  # [12, 48, 51, 19, 13]

# Приведенный ниже код, при условии, что функция filter() определена как указано выше:
def is_odd(num):
    return num % 2
def is_word_long(word):
    return len(word) > 6
numbers = list(range(15))
words = ['В', 'новом', 'списке', 'останутся', 'только', 'длинные', 'слова']
odd_numbers = filter(is_odd, numbers)
large_words = filter(is_word_long, words)
print(odd_numbers)  # [1, 3, 5, 7, 9, 11, 13]
print(large_words)  # ['останутся', 'длинные']


# Функция reduce()
# Реализованные нами функции map() и filter() работали с отдельными элементами списка независимо. Но встречаются циклы с
# агрегацией результата — формированием одного результирующего значения при комбинации элементов с использованием
# аргумента-аккумулятора.

# Типичные примеры агрегации — сумма всех элементов списка или их произведение.
# Приведенный ниже код вычисляет сумму и произведение элементов списка и выводит:
numbers = [1, 2, 3, 4, 5]
total = 0
product = 1
for num in numbers:
    total += num
    product *= num
print(total)
print(product)

# С точки зрения математики сумма 1+2+3+4+5 может быть выражена как: (((((0+1)+2)+3)+4)+5).

# Ноль здесь тот самый аккумулятор, точнее его начальное значение. Он не добавляет к сумме ничего, поэтому может служить
# отправной точкой. А еще будет результатом, если входной список пуст.

# Несложно понять, что этот цикл будет выглядеть одинаково практически во всех случаях. Меняться будет только начальное
# значение аккумулятора (0 для суммы, 1 для произведения и т.д.) и операция, которая комбинирует элемент и аккумулятор.
# Так почему бы не обобщить этот код? Так и сделаем:
def reduce(operation, items, initial_value):
    acc = initial_value
    for item in items:
        acc = operation(acc, item)
    return acc

# Приведенный ниже код, при условии, что функция reduce() определена как указано выше:
def add(x, y):
    return x+y
def mult(x, y):
    return x*y
numbers = [1, 2, 3, 4, 5]
total = reduce(add, numbers, 0)
product = reduce(mult, numbers, 1)
print(total)    # 15
print(product)  # 120


# Примечания
# Примечание 1. Мы с вами реализовали три функции:
#     map(): преобразование элементов списка;
#     filter(): фильтрация элементов списка;
#     reduce(): агрегация элементов списка.

# Каждая функция имеет меньшую мощность, чем цикл for. Цикл for позволяет гибко управлять процессом итерации, мы можем
# использовать даже команды break и continue. Возникает резонный вопрос: зачем нужны отдельные функции, когда можно
# обойтись циклом?
# Во-первых, такие функции — часть функционального подхода.
# Во-вторых, каждая такая функция делает единственную работу, что значительно упрощает рассуждение о коде, его чтение и
# написание. Взглянув на имя функции можно понять, что filter() отфильтрует, а map() — преобразует элементы. Более того,
# по построению функция filter() не меняет элементы, а лишь отбрасывает их часть. А функция map() меняет значение
# элементов, но не меняет их количество и позиции.

# Примечание 2. В математике определенная нами функция reduce() называется левая свёртка (left fold), по сути мы
# сворачиваем список в одно значение, начиная слева. Существует ещё и правая свёртка (right fold). В большинстве случаев
# обе свёртки дают одинаковый результат, если применяемая операция ассоциативна.
