# Матрицы
# В прошлых уроках мы изучили вложенные списки, то есть списки, входящие в качестве элементов в другие списки.
# Частный случай вложенных списков — матрицы — прямоугольные таблицы, заполненные какими-то значениями, обычно числами.

# Для работы с матрицами нужно уметь получать элемент i-й строки j-го столбца. Для этого обычно заводят список строк
# матрицы, где каждая строка — список элементов. Получается вложенный список или список списков. Теперь, чтобы получить
# определенный элемент, достаточно из списка строк матрицы выбрать i-ю и взять j-й элемент этой строки.

# Давайте заведем матрицу размера 3×4 (3 строки и 4 столбца), содержащую числа, и получим элемент на позиции (2, 3),
# то есть элемент второй строки в третьем столбце.

matrix = [[2, -5, -11, 0],
          [-9, 4, 6, 13],
          [4, 7, 12, -2]]
print(matrix[1][2])  # вывод элемента на позиции (2, 3)

# В переменной matrix — хранится вся матрица, при этом matrix[1] — список значений во второй строке,
# matrix[1][2] — элемент в третьем столбце этой строки.


# Перебор элементов матрицы
# Чтобы перебрать элементы матрицы, необходимо использовать вложенные циклы. Например, выведем на экран все элементы
# матрицы, перебирая их по строкам:
rows, cols = 3, 4  # rows - количество строк, cols - количество столбцов
matrix = [[2, 3, 1, 0],
          [9, 4, 6, 8],
          [4, 7, 2, 7]]
for r in range(rows):
    for c in range(cols):
        print(matrix[r][c], end=' ')
    print()
# 2 3 1 0
# 9 4 6 8
# 4 7 2 7

# Для перебора элементов матрицы по столбцам можно использовать следующий код:
rows, cols = 3, 4  # rows - количество строк, cols - количество столбцов
matrix = [[2, 3, 1, 0],
          [9, 4, 6, 8],
          [4, 7, 2, 7]]
for c in range(cols):
    for r in range(rows):
        print(matrix[r][c], end=' ')
    print()
# 2 9 4
# 3 4 7
# 1 6 2
# 0 8 7


# Функции ljust() и rjust()
rows, cols = 3, 4  # rows - количество строк, cols - количество столбцов
matrix = [[277, -930, 11, 0],
          [9, 43, 6, 87],
          [4456, 8, 290, 7]]
for r in range(rows):
    for c in range(cols):
        print(matrix[r][c], end=' ')
    print()
# 277 -930 11 0
# 9 43 6 87
# 4456 8 290 7

# Выведенная матрица не сильно похожа на упорядоченный прямоугольник. Элементы матрицы имеют разное количество разрядов
# и результат вывода получается смазанным. Для решения проблемы удобно использовать строковые методы ljust() и rjust().

# Метод ljust()
# Строковый метод ljust() выравнивает текст по ширине, добавляя пробелы в конец текста.
print('a'.ljust(3))    # a⎵⎵
print('ab'.ljust(3))   # ab⎵
print('abc'.ljust(3))  # abc

# Исходная строка не обрезается, даже если в ней больше символов, чем нужно.
print('abcdefg'.ljust(3))  # abcdefg

# Строковый метод ljust() использует вместо пробела другой символ, если передать ему второй аргумент, необязательный.
print('a'.ljust(5, '*'))    # a****
print('ab'.ljust(5, '$'))   # ab$$$
print('abc'.ljust(5, '#'))  # abc##

# Метод rjust()
# Строковый метод rjust() выравнивает текст по ширине, добавляя пробелы в начало текста.
print('a'.rjust(3))     # ⎵⎵a
print('ab'.rjust(3))    # ⎵ab
print('abc'.rjust(3))   # abc

# Исходная строка не обрезается, даже если в ней больше символов, чем нужно.
print('abcdefg'.rjust(3))  # abcdefg

# Строковый метод rjust() использует вместо пробела другой символ, если передать ему второй аргумент, необязательный.
print('a'.rjust(5, '*'))    # ****a
print('ab'.rjust(5, '$'))   # $$$ab
print('abc'.rjust(5, '#'))  # ##abc

# Применив метод ljust() для выравнивания столбцов при выводе таблицы мы получим следующий код:
rows, cols = 3, 4  # rows - количество строк, cols - количество столбцов
matrix = [[277, -930, 11, 0],
          [9, 43, 6, 87],
          [4456, 8, 290, 7]]
for r in range(rows):
    for c in range(cols):
        print(str(matrix[r][c]).ljust(6), end='')
    print()
# 277   -930  11    0
# 9     43    6     87
# 4456  8     290   7


# Квадратные матрицы
# Матрица с одинаковым количеством строк и столбцов называется квадратной. У квадратной матрицы есть две диагонали:
#     главная: проходит из верхнего левого в правый нижний угол матрицы;
#     побочная: проходит из нижнего левого в правый верхний угол матрицы.

# Элементы с равными индексами i == j находятся на главной диагонали. Такие элементы обозначаются matrix[i][i].

# Элементы с индексами i и j, связанными соотношением i + j + 1 = n (или j = n - i - 1), где n — размерность матрицы,
# находятся на побочной диагонали.

# Таким образом, чтобы установить элементы главной или побочной диагонали, достаточно одного цикла.
n = 8
matrix = [[0]*n for _ in range(n)]  # создаем квадратную матрицу размером 8×8
for i in range(n):  # заполняем главную диагональ единицами, а побочную двойками
    matrix[i][i] = 1
    matrix[i][n-i-1] = 2
for r in range(n):  # выводим матрицу
    for c in range(n):
        print(matrix[r][c], end=' ')
    print()
# 1 0 0 0 0 0 0 2
# 0 1 0 0 0 0 2 0
# 0 0 1 0 0 2 0 0
# 0 0 0 1 2 0 0 0
# 0 0 0 2 1 0 0 0
# 0 0 2 0 0 1 0 0
# 0 2 0 0 0 0 1 0
# 2 0 0 0 0 0 0 1

# Индексыi и j элементов на главной диагонали связаны соотношением i = j. Индексы i и j элементов на побочной диагонали
# связанны соотношением i + j + 1 = n (или  j = n - i - 1), где n — размерность матрицы


# Примечания
# Примечание 1. Чтобы понять, в какой области лежит элемент можно воспользоваться следующей картинкой.
# Для заполнения верхнего треугольника можно использовать условие: i < j and i < N - 1 - j
# Для заполнения нижнего треугольника можно использовать условие: i > j and i > N - 1 - j
# Для заполнения левого треугольника можно использовать условие: i > j and i < N - 1 - j
# Для заполнения правого треугольника можно использовать условие: i < j and i > N - 1 - j

# Примечание 2. Используйте функцию print_matrix() для вывода квадратной матрицы размерности n:
def print_matrix(matrix, n, width=1):
    for r in range(n):
        for c in range(n):
            print(str(matrix[r][c]).ljust(width), end=' ')
        print()

# Примечание 3. Для считывания матрицы из n строк, заполненной числами, удобно использовать следующий код:
n = int(input())
matrix = []
for i in range(n):
    temp = [int(num) for num in input().split()]
    matrix.append(temp)
